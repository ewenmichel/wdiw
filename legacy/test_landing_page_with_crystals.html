<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrystalDoor - Coming Soon</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Inter', sans-serif;
            cursor: none;
        }
        
        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #050505 0%, #000000 100%);
        }
        
        .title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 3.5rem;
            font-weight: 200;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 10;
            text-align: center;
            opacity: 0.9;
            animation: fadeIn 2s ease-out;
        }
        
        .subtitle {
            position: absolute;
            top: 57%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            pointer-events: none;
            z-index: 10;
            text-align: center;
            animation: fadeIn 2.5s ease-out;
        }
        
        .cursor-dot {
            position: fixed;
            width: 3px;
            height: 3px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            transition: opacity 0.2s ease;
        }
        
        @keyframes fadeIn {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -40%); 
            }
            100% { 
                opacity: 0.9; 
                transform: translate(-50%, -50%); 
            }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        @media (max-width: 768px) {
            .title { 
                font-size: 2rem; 
                letter-spacing: 0.2em;
            }
            .subtitle {
                font-size: 0.7rem;
            }
            .cursor-dot { 
                display: none; 
            }
            body { 
                cursor: auto; 
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    
    <h1 class="title">CrystalDoor</h1>
    <p class="subtitle">Opening soon</p>
    
    <div class="cursor-dot"></div>
    
    <script>
        const canvas = document.getElementById('canvas3d');
        const ctx = canvas.getContext('2d');
        
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        // 3D configuration
        const config = {
            particleCount: 400,
            connectionDistance: 100,
            mouseRadius: 250,
            planeRotationX: Math.PI * 0.15,
            planeRotationY: Math.PI * 0.25,
            planeDepthVariation: 0.05,
            perspective: 2200,
            centerZ: 0
        };
        
        // Mouse
        let mouse = {
            x: width / 2,
            y: height / 2,
            vx: 0,
            vy: 0,
            z: 0
        };
        
        // Custom cursor
        const cursorDot = document.querySelector('.cursor-dot');
        
        // Crystal Door class
        class CrystalDoor {
            constructor(offsetX, offsetY) {
                this.baseX = offsetX;
                this.baseY = offsetY;
                this.baseZ = 0;
                this.rotation = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
                this.scale = 80 * (1 + (this.baseX / width)); // Size of the crystal
            }
            
            rotatePoint(x, y, z) {
                // Apply same rotation as particle plane
                let tempY = y * Math.cos(config.planeRotationX) - z * Math.sin(config.planeRotationX);
                let tempZ = y * Math.sin(config.planeRotationX) + z * Math.cos(config.planeRotationX);
                y = tempY;
                z = tempZ;
                
                let tempX = x * Math.cos(config.planeRotationY) + z * Math.sin(config.planeRotationY);
                tempZ = -x * Math.sin(config.planeRotationY) + z * Math.cos(config.planeRotationY);
                x = tempX;
                z = tempZ;
                
                return { x, y, z };
            }
            
            project(x, y, z) {
                const rotated = this.rotatePoint(x, y, z);
                const scale = config.perspective / (config.perspective + rotated.z - config.centerZ);
                return {
                    x: rotated.x * scale + width / 2,
                    y: rotated.y * scale + height / 2,
                    scale: scale
                };
            }x
            
            update() {
                // Gentle floating animation
                this.rotation += 0.001;
                const floatY = Math.sin(Date.now() * 0.0005 + this.floatOffset) * 5;
                
                // Update position with float
                this.y = this.baseY + floatY;
            }
            
            draw() {
                const time = Date.now() * 0.0005;
                const floatY = Math.sin(time + this.floatOffset) * 5;
                
                // Crystal vertices in local space (hexagonal bipyramid)
                const vertices = [
                    // Top pyramid point
                    { x: 0, y: -this.scale * 1.5, z: 0 },
                    
                    // Upper hexagon
                    { x: this.scale * 0.5, y: -this.scale * 0.7, z: 0 },
                    { x: this.scale * 0.25, y: -this.scale * 0.7, z: this.scale * 0.43 },
                    { x: -this.scale * 0.25, y: -this.scale * 0.7, z: this.scale * 0.43 },
                    { x: -this.scale * 0.5, y: -this.scale * 0.7, z: 0 },
                    { x: -this.scale * 0.25, y: -this.scale * 0.7, z: -this.scale * 0.43 },
                    { x: this.scale * 0.25, y: -this.scale * 0.7, z: -this.scale * 0.43 },
                    
                    // Middle section
                    { x: this.scale * 0.6, y: 0, z: 0 },
                    { x: this.scale * 0.3, y: 0, z: this.scale * 0.52 },
                    { x: -this.scale * 0.3, y: 0, z: this.scale * 0.52 },
                    { x: -this.scale * 0.6, y: 0, z: 0 },
                    { x: -this.scale * 0.3, y: 0, z: -this.scale * 0.52 },
                    { x: this.scale * 0.3, y: 0, z: -this.scale * 0.52 },
                    
                    // Bottom pyramid point
                    { x: 0, y: this.scale * 1.5, z: 0 }
                ];
                
                // Project all vertices
                const projected = vertices.map(v => {
                    const rotY = Math.cos(this.rotation) * v.x - Math.sin(this.rotation) * v.z;
                    const rotZ = Math.sin(this.rotation) * v.x + Math.cos(this.rotation) * v.z;
                    return this.project(
                        this.baseX + rotY,
                        this.baseY + v.y + floatY,
                        this.baseZ + rotZ
                    );
                });
                
                // Draw crystal edges
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1.5;
                
                // Top pyramid edges
                for (let i = 1; i <= 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[0].x, projected[0].y);
                    ctx.lineTo(projected[i].x, projected[i].y);
                    ctx.stroke();
                }
                
                // Upper hexagon
                for (let i = 1; i <= 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[i].x, projected[i].y);
                    ctx.lineTo(projected[i === 6 ? 1 : i + 1].x, projected[i === 6 ? 1 : i + 1].y);
                    ctx.stroke();
                }
                
                // Vertical edges to middle
                for (let i = 1; i <= 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[i].x, projected[i].y);
                    ctx.lineTo(projected[i + 6].x, projected[i + 6].y);
                    ctx.stroke();
                }
                
                // Middle hexagon
                for (let i = 7; i <= 12; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[i].x, projected[i].y);
                    ctx.lineTo(projected[i === 12 ? 7 : i + 1].x, projected[i === 12 ? 7 : i + 1].y);
                    ctx.stroke();
                }
                
                // Bottom pyramid edges
                for (let i = 7; i <= 12; i++) {
                    ctx.beginPath();
                    ctx.moveTo(projected[13].x, projected[13].y);
                    ctx.lineTo(projected[i].x, projected[i].y);
                    ctx.stroke();
                }
                
                // Add subtle glow to crystal
                const centerProj = this.project(this.baseX, this.baseY + floatY, this.baseZ);
                const gradient = ctx.createRadialGradient(
                    centerProj.x, centerProj.y, 0,
                    centerProj.x, centerProj.y, this.scale * centerProj.scale * 2
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.0)');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerProj.x, centerProj.y, this.scale * centerProj.scale * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Check if a particle is near the crystal
            isNear(x, y, z, radius = 100) {
                const dx = x - this.baseX;
                const dy = y - this.baseY;
                const dz = z - this.baseZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz) < radius;
            }
        }
        
        // Create two crystal doors
        const crystals = [
            new CrystalDoor(-120, -300),
            new CrystalDoor(120, 450),
            new CrystalDoor(-600, 200),
            new CrystalDoor(-1200, -550),
            new CrystalDoor(-1600, 800),
            new CrystalDoor(-1000, 0),
            new CrystalDoor(-650, -700),
            new CrystalDoor(540, -180),
        ];
        
        class Particle3D {
            constructor(index) {
                const gridSize = Math.ceil(Math.sqrt(config.particleCount));
                const gridX = (index % gridSize) / gridSize - 0.5;
                const gridY = Math.floor(index / gridSize) / gridSize - 0.5;
                
                this.baseX = gridX * width * 1.5;
                this.baseY = gridY * height * 1.5;
                this.baseZ = (Math.random() - 0.5) * config.planeDepthVariation * 500;
                
                const rotatedPos = this.rotatePoint(this.baseX, this.baseY, this.baseZ);
                this.baseX = rotatedPos.x;
                this.baseY = rotatedPos.y;
                this.baseZ = rotatedPos.z;
                
                this.x = this.baseX;
                this.y = this.baseY;
                this.z = this.baseZ;
                
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.vz = (Math.random() - 0.5) * 0.1;
                
                this.radius = Math.random() * 1.5 + 0.5;
                this.opacity = Math.random() * 0.5 + 0.5;
            }
            
            rotatePoint(x, y, z) {
                let tempY = y * Math.cos(config.planeRotationX) - z * Math.sin(config.planeRotationX);
                let tempZ = y * Math.sin(config.planeRotationX) + z * Math.cos(config.planeRotationX);
                y = tempY;
                z = tempZ;
                
                let tempX = x * Math.cos(config.planeRotationY) + z * Math.sin(config.planeRotationY);
                tempZ = -x * Math.sin(config.planeRotationY) + z * Math.cos(config.planeRotationY);
                x = tempX;
                z = tempZ;
                
                return { x, y, z };
            }
            
            project() {
                const scale = config.perspective / (config.perspective + this.z - config.centerZ);
                return {
                    x: this.x * scale + width / 2,
                    y: this.y * scale + height / 2,
                    scale: scale,
                    opacity: scale * this.opacity
                };
            }
            
            update() {
                this.baseX += this.vx;
                this.baseY += this.vy;
                this.baseZ += this.vz;
                
                const bounds = 400;
                if (Math.abs(this.baseX) > bounds) this.vx *= -1;
                if (Math.abs(this.baseY) > bounds) this.vy *= -1;
                if (Math.abs(this.baseZ) > 20) this.vz *= -1;
                
                // Crystal repulsion
                let crystalForceX = 0;
                let crystalForceY = 0;
                let crystalForceZ = 0;
                
                crystals.forEach(crystal => {
                    if (crystal.isNear(this.baseX, this.baseY, this.baseZ, 120)) {
                        const dx = this.baseX - crystal.baseX;
                        const dy = this.baseY - crystal.baseY;
                        const dz = this.baseZ - crystal.baseZ;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (dist > 0 && dist < 120) {
                            const force = (1 - dist / 120) * 10;
                            crystalForceX += (dx / dist) * force;
                            crystalForceY += (dy / dist) * force;
                            crystalForceZ += (dz / dist) * force;
                        }
                    }
                });
                
                // Mouse interaction
                const projected = this.project();
                const dx = mouse.x - projected.x;
                const dy = mouse.y - projected.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < config.mouseRadius) {
                    const force = (1 - distance / config.mouseRadius);
                    const force3D = force * 30;
                    
                    const angle = Math.atan2(dy, dx);
                    const attractionX = Math.cos(angle) * force3D;
                    const attractionY = Math.sin(angle) * force3D;
                    
                    this.x = this.baseX + attractionX / projected.scale + crystalForceX;
                    this.y = this.baseY + attractionY / projected.scale + crystalForceY;
                    this.z = this.baseZ + Math.sin(Date.now() * 0.001 + this.baseX) * force * 10 + crystalForceZ;
                } else {
                    this.x += (this.baseX - this.x) * 0.1 + crystalForceX * 0.1;
                    this.y += (this.baseY - this.y) * 0.1 + crystalForceY * 0.1;
                    this.z += (this.baseZ - this.z) * 0.1 + crystalForceZ * 0.1;
                }
            }
            
            draw() {
                const p = this.project();
                
                if (p.scale <= 0) return;
                
                ctx.save();
                
                const size = this.radius * p.scale;
                
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 3);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${p.opacity * 0.8})`);
                gradient.addColorStop(0.5, `rgba(255, 255, 255, ${p.opacity * 0.8})`);
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity * 0.9})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        const particles = [];
        for (let i = 0; i < config.particleCount; i++) {
            particles.push(new Particle3D(i));
        }
        
        function sortByDepth(items) {
            return items.sort((a, b) => b.z - a.z);
        }
        
        function drawConnections() {
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                const proj1 = p1.project();
                
                if (proj1.scale <= 0) continue;
                
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    const proj2 = p2.project();
                    
                    if (proj2.scale <= 0) continue;
                    
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dz = p1.z - p2.z;
                    const distance3D = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance3D < config.connectionDistance) {
                        const opacity = (1 - distance3D / config.connectionDistance) * 0.2;
                        
                        const screenDist1 = Math.sqrt(
                            Math.pow(proj1.x - mouse.x, 2) + 
                            Math.pow(proj1.y - mouse.y, 2)
                        );
                        const screenDist2 = Math.sqrt(
                            Math.pow(proj2.x - mouse.x, 2) + 
                            Math.pow(proj2.y - mouse.y, 2)
                        );
                        const avgMouseDist = (screenDist1 + screenDist2) / 2;
                        
                        if (avgMouseDist < config.mouseRadius) {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 2})`;
                            ctx.lineWidth = 4.5;
                        } else {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                            ctx.lineWidth = 4.5;
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(proj1.x, proj1.y);
                        ctx.lineTo(proj2.x, proj2.y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
            ctx.fillRect(0, 0, width, height);
            
            // Update everything
            crystals.forEach(crystal => crystal.update());
            particles.forEach(particle => particle.update());
            
            // Sort all 3D objects by depth
            const allObjects = [
                ...particles.map(p => ({ type: 'particle', obj: p, z: p.z })),
                ...crystals.map(c => ({ type: 'crystal', obj: c, z: c.baseZ }))
            ].sort((a, b) => b.z - a.z);
            
            // Draw connections first (behind everything)
            drawConnections();
            
            // Draw sorted objects
            allObjects.forEach(item => {
                if (item.type === 'particle') {
                    item.obj.draw();
                } else {
                    item.obj.draw();
                }
            });
            
            mouse.vx *= 0.95;
            mouse.vy *= 0.95;
            
            requestAnimationFrame(animate);
        }
        
        let lastMouse = { x: width / 2, y: height / 2 };
        
        document.addEventListener('mousemove', (e) => {
            lastMouse.x = mouse.x;
            lastMouse.y = mouse.y;
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            mouse.vx = mouse.x - lastMouse.x;
            mouse.vy = mouse.y - lastMouse.y;
            
            cursorDot.style.left = e.clientX + 'px';
            cursorDot.style.top = e.clientY + 'px';
        });
        
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            lastMouse.x = mouse.x;
            lastMouse.y = mouse.y;
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
            mouse.vx = mouse.x - lastMouse.x;
            mouse.vy = mouse.y - lastMouse.y;
        });
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });
        
        animate();
    </script>
</body>
</html>